---
import { getColor, formatPercent } from "../lib/utils";

interface Props {
  data: any[];
  type: "models" | "generations";
  mode?: "simple" | "cot"; // For model comparison dashboard
  modelSlug?: string; // For generation links
  genType?: "simple" | "cot"; // Type of generation data
  experimentId?: string; // Current experiment ID
}

const {
  data,
  type,
  mode,
  modelSlug,
  genType = "simple",
  experimentId,
} = Astro.props;

// Column definitions
const columns = [
  { key: "syntax", label: "Syntax", isValidation: true },
  { key: "multiplicities", label: "Mult", isValidation: true },
  { key: "invariants", label: "Inv", isValidation: true },
  { key: "coverage.coverage.classes", label: "Cov.Cls" },
  { key: "coverage.coverage.attributes", label: "Cov.Attr" },
  { key: "coverage.coverage.relationships", label: "Cov.Rel" },
  { key: "coverage.instantiation.classes", label: "Inst.Cls", isCount: true },
  {
    key: "coverage.instantiation.attributes",
    label: "Inst.Attr",
    isCount: true,
  },
  {
    key: "coverage.instantiation.relationships",
    label: "Inst.Rel",
    isCount: true,
  },
  { key: "realism", label: "Realism", isRealism: true },
  { key: "diversity.numeric", label: "Num.Eq" },
  { key: "diversity.stringEquals", label: "Str.Eq" },
  { key: "diversity.stringLv", label: "Str.LV" },
];

function getValue(obj: any, path: string): any {
  if (!obj) return null;
  return path.split(".").reduce((acc, part) => acc?.[part], obj);
}

function getDataSource(item: any): any {
  if (mode && item[mode]) return item[mode];
  if (type === "generations") {
    // For both Simple and CoT, use the generation-level aggregated metrics if available
    // Fall back to item itself if no metrics field exists (backward compatibility)
    return item.metrics || item;
  }
  return item;
}

function formatValue(
  value: any,
  col: any,
  isGeneration: boolean,
  source: any,
): string {
  if (value === null || value === undefined) return "—";

  if (col.isRealism) {
    if (isGeneration) return source?.judge?.response || "—";
    return formatPercent(value);
  }

  if (col.isCount) {
    return typeof value === "number"
      ? isGeneration
        ? Math.round(value).toString()
        : value.toFixed(1)
      : String(value);
  }

  // Handle MetricStat objects {errors, total} for validation columns
  if (typeof value === "object" && "errors" in value && "total" in value) {
    const rate = value.total > 0 ? 1 - value.errors / value.total : 1;
    return formatPercent(rate);
  }

  return formatPercent(value);
}

function getCellStyle(value: any, col: any, isGeneration: boolean): string {
  if (value === null || value === undefined || col.isCount || col.isRealism)
    return "";

  // Convert MetricStat to rate for coloring
  let rate = value;
  if (typeof value === "object" && "errors" in value && "total" in value) {
    rate = value.total > 0 ? 1 - value.errors / value.total : 1;
  }

  if (isGeneration && col.isValidation) {
    // For validation success rate in generations: Green 1.0, Red 0.0
    return getColor(rate, 1, 0);
  }

  // Apply heatmap color (Green 0.9, Red 0.5)
  return getColor(rate, 0.9, 0.5);
}

const isGeneration = type === "generations";
---

<div class="table-wrapper">
  <table class="data-table">
    <thead>
      <tr>
        <th class="sticky-col name-header">Name</th>
        {columns.map((col) => <th title={col.label}>{col.label}</th>)}
      </tr>
    </thead>
    <tbody>
      {
        data.map((item: any) => {
          const name = item.name || item.id;
          // Build path-based URL: /:experiment/:model or /:experiment/:model/:gen
          const baseHref =
            type === "models"
              ? `/${experimentId}/${name.toLowerCase()}`
              : `/${experimentId}/${modelSlug}/${item.id}`;
          const isCotLink = genType === "cot" || mode === "cot";

          // Build query parameters (no longer need experimentId - it's in path)
          const params = new URLSearchParams();
          if (isCotLink) params.set("type", "cot");

          const href = params.toString()
            ? `${baseHref}?${params.toString()}`
            : baseHref;
          const source = getDataSource(item);

          return (
            <tr>
              <td class="name-cell sticky-col">
                <a href={href}>{name}</a>
              </td>
              {columns.map((col) => {
                const value = getValue(source, col.key);
                const style = getCellStyle(value, col, isGeneration);
                const displayValue = formatValue(
                  value,
                  col,
                  isGeneration,
                  source,
                );

                return <td style={style || undefined}>{displayValue}</td>;
              })}
            </tr>
          );
        })
      }
    </tbody>
  </table>
</div>

<style>
  .table-wrapper {
    overflow-x: auto;
  }
  .data-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.75rem;
  }
  .data-table th,
  .data-table td {
    padding: 0.4rem 0.5rem;
    text-align: center;
    border-bottom: 1px solid var(--color-border);
    white-space: nowrap;
  }
  .data-table th {
    font-size: 0.65rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.025em;
    color: var(--color-secondary);
    background: var(--color-surface);
  }
  .data-table .name-header,
  .data-table .name-cell {
    text-align: left !important;
  }
  .data-table .name-cell {
    font-weight: 500;
  }
  .name-cell a {
    color: var(--color-link);

    text-decoration: none;
  }
  .name-cell a:hover {
    text-decoration: underline;
  }
  .sticky-col {
    position: sticky;
    left: 0;
    background: var(--color-background);
    z-index: 1;
  }
  tbody tr:hover {
    background: var(--color-surface);
  }
  tbody tr:hover .sticky-col {
    background: var(--color-surface);
  }
</style>
