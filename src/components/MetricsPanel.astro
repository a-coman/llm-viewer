---
import {
  getColor,
  getBinaryColor,
  formatPercent,
  formatCurrency,
} from "../lib/utils";
import { COLOR_RANGES, INFINITY_SYMBOL } from "../lib/constants";
import Tooltip from "./Tooltip.astro";

interface MetricStat {
  errors: number;
  total: number;
}

interface InstantiationValueItem {
  value: number;
  total: number | null; // null = infinity
}

interface InstantiationItem {
  classes: InstantiationValueItem;
  attributes: InstantiationValueItem;
  relationships: InstantiationValueItem;
}

interface Metrics {
  syntax?: number | MetricStat;
  multiplicities?: number | MetricStat;
  invariants?: number | MetricStat;
  coverage?: {
    coverage: { classes: number; attributes: number; relationships: number };
    instantiation: InstantiationItem;
  };
  diversity?: {
    numeric: number;
    stringEquals: number;
    stringLv: number;
    ged?: { mean: number; std: number };
  };
  judge?: { successRate: number };
  price?: { price: number };
  instantiation?: InstantiationItem;
  realism?: number;
}

interface Props {
  title?: string;
  metrics: Metrics | any;
  showSections?: {
    cost?: boolean;
    validation?: boolean;
    coverage?: boolean;
    instantiation?: boolean;
    diversity?: boolean;
    quality?: boolean;
  };
  isInvalidCategory?: boolean;
  priceRange?: { green: number; red: number };
}

const {
  metrics,
  title,
  showSections = {
    cost: true,
    validation: true,
    coverage: true,
    instantiation: true,
    diversity: true,
    quality: true,
  },
  isInvalidCategory = false,
  priceRange = COLOR_RANGES.price.summary,
} = Astro.props;

function getDisplayValue(
  val: any,
  type: "percent" | "count" | "currency" = "percent",
  metricKey: string = "",
): { text: string; style: string } {
  if (val === undefined || val === null) return { text: "—", style: "" };

  if (type === "currency") {
    const price = typeof val === "object" ? val.price : val;
    return {
      text: formatCurrency(price),
      style: getColor(price, priceRange.green, priceRange.red),
    };
  }

  if (typeof val === "object" && "errors" in val) {
    const hasErrors = val.errors > 0;
    // For "invalid" category: only multiplicities and invariants are inverted
    // (errors expected = green), syntax stays normal (no errors = green)
    const shouldInvert = isInvalidCategory && metricKey !== "syntax";
    const isGood = shouldInvert ? hasErrors : !hasErrors;
    return {
      text: `${val.errors}/${val.total}`,
      style: getBinaryColor(isGood),
    };
  }

  if (typeof val === "number") {
    if (type === "count")
      return { text: Math.round(val).toString(), style: "" };
    // For percentages: use gradient (green = 100%, red = 0%)
    // For invalid category multiplicities/invariants: inverted
    const shouldInvert = isInvalidCategory && metricKey !== "syntax";
    const colorVal = shouldInvert ? 1 - val : val;
    return {
      text: formatPercent(val),
      style: getColor(
        colorVal,
        COLOR_RANGES.validation.percent.green,
        COLOR_RANGES.validation.percent.red,
      ),
    };
  }

  return { text: "—", style: "" };
}

// Helper for instantiation display: value/total or value/∞
function getInstantiationDisplay(
  item: InstantiationValueItem | undefined,
  key: string,
): { text: string; style: string } {
  if (!item || item.value === undefined) return { text: "—", style: "" };

  const value = Math.round(item.value);
  const total = item.total;

  if (total === null) {
    // Infinity case (classes/relationships) - always green
    return {
      text: `${value}/${INFINITY_SYMBOL}`,
      style: getBinaryColor(true),
    };
  }

  // Has a finite total (attributes) - use percentage coloring
  const totalRound = Math.round(total);
  const ratio = totalRound > 0 ? value / totalRound : 1;
  return {
    text: `${value}/${totalRound}`,
    style: getColor(
      ratio,
      COLOR_RANGES.validation.percent.green,
      COLOR_RANGES.validation.percent.red,
    ),
  };
}

const cov = metrics?.coverage?.coverage || metrics?.coverage;
const inst = metrics?.coverage?.instantiation || metrics?.instantiation;
const div = metrics?.diversity;
const judge = metrics?.judge || { successRate: metrics?.realism };
const price = metrics?.price;
---

<div class="metrics-panel">
  {title && <h2 class="sober-header">{title}</h2>}

  {
    showSections.cost &&
      (price !== undefined || metrics?.cost !== undefined) && (
        <div class="metric-section">
          <h3 class="sober-label">
            Cost
            <Tooltip metricType="cost" />
          </h3>

          <table class="metrics-table">
            <tbody>
              <tr>
                <td>Total Cost</td>
                <td
                  style={
                    getDisplayValue(price ?? metrics?.cost, "currency").style
                  }
                >
                  {getDisplayValue(price ?? metrics?.cost, "currency").text}
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      )
  }

  {
    showSections.validation && (
      <div class="metric-section">
        <h3 class="sober-label">
          Validation
          <Tooltip metricType="validation" />
        </h3>

        <table class="metrics-table">
          <tbody>
            {["syntax", "multiplicities", "invariants"].map((key) => {
              // Check both root level and nested metrics.metrics level
              const val = metrics?.[key] ?? metrics?.metrics?.[key];
              const { text, style } = getDisplayValue(val, "percent", key);
              const label = key.charAt(0).toUpperCase() + key.slice(1);
              return (
                <tr>
                  <td>{label}</td>
                  <td style={style}>{text}</td>
                </tr>
              );
            })}
          </tbody>
        </table>
      </div>
    )
  }

  {
    showSections.diversity && div && (
      <div class="metric-section">
        <h3 class="sober-label">
          Diversity
          <Tooltip metricType="diversity" />
        </h3>

        <table class="metrics-table">
          <tbody>
            <tr>
              <td>Numeric</td>
              <td style={getDisplayValue(div.numeric).style}>
                {getDisplayValue(div.numeric).text}
              </td>
            </tr>
            <tr>
              <td>String Equals</td>
              <td style={getDisplayValue(div.stringEquals).style}>
                {getDisplayValue(div.stringEquals).text}
              </td>
            </tr>
            <tr>
              <td>String LV</td>
              <td style={getDisplayValue(div.stringLv).style}>
                {getDisplayValue(div.stringLv).text}
              </td>
            </tr>
            {div.ged && (
              <tr>
                <td>GED</td>
                <td style={getColor(div.ged.mean, 0.5, 0.9)}>
                  {div.ged.mean.toFixed(3)} ± {div.ged.std.toFixed(3)}
                </td>
              </tr>
            )}
          </tbody>
        </table>
      </div>
    )
  }

  {
    showSections.coverage && cov && (
      <div class="metric-section">
        <h3 class="sober-label">
          Coverage
          <Tooltip metricType="coverage" />
        </h3>

        <table class="metrics-table">
          <tbody>
            {Object.entries(cov).map(([key, val]) => {
              const { text, style } = getDisplayValue(val);
              const label = key.charAt(0).toUpperCase() + key.slice(1);
              return (
                <tr>
                  <td>{label}</td>
                  <td style={style}>{text}</td>
                </tr>
              );
            })}
          </tbody>
        </table>
      </div>
    )
  }

  {
    showSections.instantiation && inst && (
      <div class="metric-section">
        <h3 class="sober-label">
          Instantiation
          <Tooltip metricType="instantiation" />
        </h3>

        <table class="metrics-table">
          <tbody>
            {Object.entries(inst).map(([key, val]) => {
              const { text, style } = getInstantiationDisplay(
                val as InstantiationValueItem,
                key,
              );
              const label = key.charAt(0).toUpperCase() + key.slice(1);
              return (
                <tr>
                  <td>{label}</td>
                  <td style={style}>{text}</td>
                </tr>
              );
            })}
          </tbody>
        </table>
      </div>
    )
  }

  {
    showSections.quality && judge && (
      <div class="metric-section">
        <h3 class="sober-label">
          Quality
          <Tooltip metricType="realism" />
        </h3>

        <table class="metrics-table">
          <tbody>
            <tr>
              <td>Realism</td>
              <td style={getDisplayValue(judge.successRate).style}>
                {getDisplayValue(judge.successRate).text}
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    )
  }
</div>

<style>
  .metrics-panel {
    background: var(--color-background);
    border: 1px solid var(--color-border);
    height: 100%;
    display: flex;
    flex-direction: column;
  }

  .metric-section {
    border-bottom: 1px solid var(--color-border);
  }

  .metric-section:last-child {
    border-bottom: none;
  }

  .metrics-table {
    margin: 0;
  }
</style>
