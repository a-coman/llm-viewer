---
interface Props {
  src: string;
  title?: string;
  height?: string;
  available?: boolean;
}

const {
  src,
  title = "PDF Document",
  height = "100%",
  available = true,
} = Astro.props;
---

{
  available ? (
    <div class="pdf-container" style={`height: ${height};`} data-src={src}>
      <div class="pdf-world">
        <canvas class="pdf-canvas" />
      </div>
    </div>
  ) : (
    <div class="sober-empty-state" style={`height: ${height};`}>
      <div class="sober-empty-text">PDF Unavailable</div>
      <div class="sober-empty-hint">{title}</div>
    </div>
  )
}

<script>
  import * as pdfjsLib from "pdfjs-dist";

  pdfjsLib.GlobalWorkerOptions.workerSrc = `https://unpkg.com/pdfjs-dist@${pdfjsLib.version}/build/pdf.worker.min.mjs`;

  class PdfViewer {
    container: HTMLElement;
    world: HTMLElement;
    canvas: HTMLCanvasElement;
    ctx: CanvasRenderingContext2D;
    url: string;
    scale: number;
    contentScale: number;
    posX: number;
    posY: number;
    isDragging: boolean;
    startX: number;
    startY: number;
    _hasFit: boolean;
    _fitRetryTimer: number | null;
    _resizeObserver: ResizeObserver | null;

    constructor(container: HTMLElement) {
      this.container = container;
      this.world = container.querySelector(".pdf-world")!;
      this.canvas = container.querySelector(".pdf-canvas")!;
      this.ctx = this.canvas.getContext("2d")!;
      this.url = container.dataset.src || "";

      this.scale = 1;
      this.contentScale = 2.0;
      this.posX = 0;
      this.posY = 0;
      this.isDragging = false;
      this.startX = 0;
      this.startY = 0;

      this._hasFit = false;
      this._fitRetryTimer = null;
      this._resizeObserver = null;

      this.init();
    }

    scheduleFit() {
      if (this._fitRetryTimer) return;
      this._fitRetryTimer = window.setTimeout(() => {
        this._fitRetryTimer = null;
        this.fitToContainer();
      }, 50);
    }

    fitToContainer() {
      const containerRect = this.container.getBoundingClientRect();

      if (containerRect.width === 0 || containerRect.height === 0) {
        this.scheduleFit();
        return;
      }

      const effectiveWidth = this.canvas.width;
      const effectiveHeight = this.canvas.height;
      if (!effectiveWidth || !effectiveHeight) {
        this.scheduleFit();
        return;
      }

      const scaleX = containerRect.width / effectiveWidth;
      const scaleY = containerRect.height / effectiveHeight;
      const fitScale = Math.min(scaleX, scaleY) * 0.95;

      if (this._hasFit && (this.isDragging || this.scale !== fitScale)) {
        return;
      }

      this.scale = fitScale;
      const scaledWidth = effectiveWidth * this.scale;
      const scaledHeight = effectiveHeight * this.scale;
      this.posX = (containerRect.width - scaledWidth) / 2;
      this.posY = (containerRect.height - scaledHeight) / 2;

      this._hasFit = true;
      this.updateTransform();
    }

    async init() {
      try {
        const loadingTask = pdfjsLib.getDocument(this.url);
        const pdf = await loadingTask.promise;
        const page = await pdf.getPage(1);

        const viewport = page.getViewport({ scale: this.contentScale });

        this.canvas.height = viewport.height;
        this.canvas.width = viewport.width;

        const renderContext = {
          canvasContext: this.ctx,
          canvas: this.canvas,
          viewport: viewport,
        };

        await page.render(renderContext).promise;

        this.fitToContainer();

        this._resizeObserver = new ResizeObserver(() => this.fitToContainer());
        this._resizeObserver.observe(this.container);

        this.addEventListeners();
      } catch (error: any) {
        console.error("Error loading PDF:", error);
        this.container.innerHTML = `
          <div class="sober-empty-state error">
            <div class="sober-empty-text">Load Failed</div>
            <div class="sober-empty-hint">${error.message}</div>
          </div>
        `;
      }
    }

    addEventListeners() {
      const getEventPos = (e: MouseEvent) => {
        const rect = this.container.getBoundingClientRect();
        return {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top,
        };
      };

      this.container.addEventListener("mousedown", (e) => {
        if (e.button !== 0) return;
        this.isDragging = true;
        const { x, y } = getEventPos(e);
        this.startX = x - this.posX;
        this.startY = y - this.posY;
        this.container.style.cursor = "grabbing";
      });

      window.addEventListener("mousemove", (e) => {
        if (!this.isDragging) return;
        e.preventDefault();
        const rect = this.container.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        this.posX = x - this.startX;
        this.posY = y - this.startY;
        this.updateTransform();
      });

      window.addEventListener("mouseup", () => {
        this.isDragging = false;
        this.container.style.cursor = "grab";
      });

      this.container.addEventListener(
        "wheel",
        (e) => {
          e.preventDefault();
          const { x: mouseX, y: mouseY } = getEventPos(e);

          const zoomIntensity = 0.1;
          const delta =
            e.deltaY < 0 ? 1 + zoomIntensity : 1 / (1 + zoomIntensity);

          const oldScale = this.scale;
          let newScale = oldScale * delta;
          newScale = Math.min(Math.max(0.1, newScale), 5);

          const worldX = (mouseX - this.posX) / oldScale;
          const worldY = (mouseY - this.posY) / oldScale;

          this.posX = mouseX - worldX * newScale;
          this.posY = mouseY - worldY * newScale;
          this.scale = newScale;

          this.updateTransform();
        },
        { passive: false },
      );
    }

    updateTransform() {
      this.world.style.transform = `translate(${this.posX}px, ${this.posY}px) scale(${this.scale})`;
    }
  }

  document.querySelectorAll(".pdf-container").forEach((el) => {
    if ((el as any)._pdfViewer) return;
    (el as any)._pdfViewer = new PdfViewer(el as HTMLElement);
  });
</script>

<style>
  .pdf-container {
    position: relative;
    overflow: hidden;
    background: white;
    cursor: grab;
    width: 100%;
  }

  .pdf-world {
    position: absolute;
    top: 0;
    left: 0;
    transform-origin: 0 0;
    will-change: transform;
    user-select: none;
  }

  .pdf-canvas {
    display: block;
    background: white;
  }
</style>
