---
interface Props {
  src: string;
  title?: string;
  height?: string;
  available?: boolean;
}

const {
  src,
  title = "PDF Document",
  height = "500px",
  available = true,
} = Astro.props;
---

{
  available ? (
    <div class="pdf-container" style={`height: ${height};`} data-src={src}>
      <div class="pdf-world">
        <canvas class="pdf-canvas" />
      </div>
    </div>
  ) : (
    <div class="unavailable">
      <div class="unavailable-icon">ðŸ“„</div>
      <span class="unavailable-text">PDF Unavailable</span>
      <span class="unavailable-hint">{title}</span>
    </div>
  )
}

<script>
  import * as pdfjsLib from "pdfjs-dist";

  // Set worker from CDN for easier static hosting compatibility
  // Note: pdfjs-dist v4+ uses .mjs extension for the worker
  pdfjsLib.GlobalWorkerOptions.workerSrc = `https://unpkg.com/pdfjs-dist@${pdfjsLib.version}/build/pdf.worker.min.mjs`;

  class PdfViewer {
    constructor(container) {
      this.container = container;
      this.world = container.querySelector(".pdf-world");
      this.canvas = container.querySelector(".pdf-canvas");
      this.ctx = this.canvas.getContext("2d");
      this.url = container.dataset.src || "";

      this.scale = 1;
      this.contentScale = 2.0; // Render at higher resolution
      this.posX = 0;
      this.posY = 0;
      this.isDragging = false;
      this.startX = 0;
      this.startY = 0;

      this._hasFit = false;
      this._fitRetryTimer = null;
      this._resizeObserver = null;

      this.init();
    }

    scheduleFit() {
      if (this._fitRetryTimer) return;
      this._fitRetryTimer = window.setTimeout(() => {
        this._fitRetryTimer = null;
        this.fitToContainer();
      }, 50);
    }

    fitToContainer() {
      const containerRect = this.container.getBoundingClientRect();

      // If hidden (display:none), width/height will be 0. Retry later.
      if (containerRect.width === 0 || containerRect.height === 0) {
        this.scheduleFit();
        return;
      }

      const effectiveWidth = this.canvas.width;
      const effectiveHeight = this.canvas.height;
      if (!effectiveWidth || !effectiveHeight) {
        this.scheduleFit();
        return;
      }

      const scaleX = containerRect.width / effectiveWidth;
      const scaleY = containerRect.height / effectiveHeight;
      const fitScale = Math.min(scaleX, scaleY) * 0.95;

      // If user already interacted, do not override their transform.
      if (this._hasFit && (this.isDragging || this.scale !== fitScale)) {
        return;
      }

      this.scale = fitScale;
      const scaledWidth = effectiveWidth * this.scale;
      const scaledHeight = effectiveHeight * this.scale;
      this.posX = (containerRect.width - scaledWidth) / 2;
      this.posY = (containerRect.height - scaledHeight) / 2;

      this._hasFit = true;
      this.updateTransform();
    }

    async init() {
      try {
        const loadingTask = pdfjsLib.getDocument(this.url);
        const pdf = await loadingTask.promise;
        const page = await pdf.getPage(1);

        const viewport = page.getViewport({ scale: this.contentScale });

        this.canvas.height = viewport.height;
        this.canvas.width = viewport.width;

        const renderContext = {
          canvasContext: this.ctx,
          viewport: viewport,
        };
        await page.render(renderContext).promise;

        // Fit now (or retry if hidden)
        this.fitToContainer();

        // Refit when the element becomes visible / resizes (tab switching toggles display)
        this._resizeObserver = new ResizeObserver(() => this.fitToContainer());
        this._resizeObserver.observe(this.container);

        this.addEventListeners();
      } catch (error) {
        console.error("Error loading PDF:", error);
        this.container.innerHTML = `<div class="error">Failed to load PDF: ${error.message}</div>`;
      }
    }

    addEventListeners() {
      const getEventPos = (e) => {
        const rect = this.container.getBoundingClientRect();
        return {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top,
        };
      };

      this.container.addEventListener("mousedown", (e) => {
        if (e.button !== 0) return; // Only left click
        this.isDragging = true;
        const { x, y } = getEventPos(e);
        this.startX = x - this.posX;
        this.startY = y - this.posY;
        this.container.style.cursor = "grabbing";
      });

      window.addEventListener("mousemove", (e) => {
        if (!this.isDragging) return;
        e.preventDefault();
        const rect = this.container.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        this.posX = x - this.startX;
        this.posY = y - this.startY;
        this.updateTransform();
      });

      window.addEventListener("mouseup", () => {
        this.isDragging = false;
        this.container.style.cursor = "grab";
      });

      this.container.addEventListener(
        "wheel",
        (e) => {
          e.preventDefault();
          const { x: mouseX, y: mouseY } = getEventPos(e);

          const zoomIntensity = 0.1;
          const delta =
            e.deltaY < 0 ? 1 + zoomIntensity : 1 / (1 + zoomIntensity);

          const oldScale = this.scale;
          let newScale = oldScale * delta;
          newScale = Math.min(Math.max(0.1, newScale), 5); // Limits

          const worldX = (mouseX - this.posX) / oldScale;
          const worldY = (mouseY - this.posY) / oldScale;

          this.posX = mouseX - worldX * newScale;
          this.posY = mouseY - worldY * newScale;
          this.scale = newScale;

          this.updateTransform();
        },
        { passive: false }
      );
    }

    updateTransform() {
      this.world.style.transform = `translate(${this.posX}px, ${this.posY}px) scale(${this.scale})`;
    }
  }

  // Initialize
  document.querySelectorAll(".pdf-container").forEach((el) => {
    // Check if already initialized to prevent duplicates if multiple runs
    if (el._pdfViewer) return;
    el._pdfViewer = new PdfViewer(el);
  });
</script>

<style>
  .pdf-container {
    position: relative;
    overflow: hidden;
    background: white;
    cursor: grab;
    width: 100%;
    height: 100%;
    min-height: 500px;
    /* height is set inline */
  }

  .pdf-world {
    position: absolute;
    top: 0;
    left: 0;
    transform-origin: 0 0;
    will-change: transform;
    /* Prevent selection during drag */
    user-select: none;
  }

  .pdf-canvas {
    display: block;
    background: white;
  }

  .error {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    color: #ef4444;
    font-size: 0.875rem;
  }

  /* Unchanged Styles */
  .unavailable {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 3rem 2rem;
    background: #f8fafc;
    border: 2px dashed #cbd5e1;
    border-radius: 0.5rem;
    text-align: center;
  }

  .unavailable-icon {
    font-size: 3rem;
    margin-bottom: 1rem;
    opacity: 0.5;
  }

  .unavailable-text {
    font-size: 1rem;
    font-weight: 600;
    color: #64748b;
  }

  .unavailable-hint {
    font-size: 0.75rem;
    color: #94a3b8;
    margin-top: 0.5rem;
  }
</style>
